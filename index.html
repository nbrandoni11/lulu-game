<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>LULU v092025</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; background:#000; overflow:hidden; }
    body { display:flex; align-items:center; justify-content:center; }
    canvas { display:block; touch-action:none; image-rendering: pixelated; image-rendering: crisp-edges; }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<script>
(() => {
  // ============================================================
  // Retro buffer + responsive presentation
  // ============================================================
  const W = 256, H = 240;
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  ctx.imageSmoothingEnabled = false;

  const buf = document.createElement("canvas");
  buf.width = W; buf.height = H;
  const g = buf.getContext("2d");
  g.imageSmoothingEnabled = false;

  function resize() {
    const vw = window.innerWidth, vh = window.innerHeight;
    const scale = Math.max(1, Math.floor(Math.min(vw / W, vh / H))); // integer scale
    canvas.width = W * scale;
    canvas.height = H * scale;
    canvas.style.width = (W * scale) + "px";
    canvas.style.height = (H * scale) + "px";
    ctx.imageSmoothingEnabled = false;
  }
  window.addEventListener("resize", resize);
  resize();

  function present() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(buf, 0, 0, W, H, 0, 0, canvas.width, canvas.height);
  }

  function toInternal(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const x = (clientX - rect.left) * (W / rect.width);
    const y = (clientY - rect.top)  * (H / rect.height);
    return { x, y };
  }

  // ============================================================
  // 5x7 font
  // ============================================================
  const FONT = {
    "A":["01110","10001","10001","11111","10001","10001","10001"],
    "B":["11110","10001","10001","11110","10001","10001","11110"],
    "C":["01111","10000","10000","10000","10000","10000","01111"],
    "D":["11110","10001","10001","10001","10001","10001","11110"],
    "E":["11111","10000","10000","11110","10000","10000","11111"],
    "F":["11111","10000","10000","11110","10000","10000","10000"],
    "G":["01111","10000","10000","10111","10001","10001","01111"],
    "H":["10001","10001","10001","11111","10001","10001","10001"],
    "I":["11111","00100","00100","00100","00100","00100","11111"],
    "J":["00111","00010","00010","00010","10010","10010","01100"],
    "K":["10001","10010","10100","11000","10100","10010","10001"],
    "L":["10000","10000","10000","10000","10000","10000","11111"],
    "M":["10001","11011","10101","10101","10001","10001","10001"],
    "N":["10001","11001","10101","10011","10001","10001","10001"],
    "O":["01110","10001","10001","10001","10001","10001","01110"],
    "P":["11110","10001","10001","11110","10000","10000","10000"],
    "Q":["01110","10001","10001","10001","10101","10010","01101"],
    "R":["11110","10001","10001","11110","10100","10010","10001"],
    "S":["01111","10000","10000","01110","00001","00001","11110"],
    "T":["11111","00100","00100","00100","00100","00100","00100"],
    "U":["10001","10001","10001","10001","10001","10001","01110"],
    "V":["10001","10001","10001","10001","10001","01010","00100"],
    "W":["10001","10001","10001","10101","10101","11011","10001"],
    "X":["10001","10001","01010","00100","01010","10001","10001"],
    "Y":["10001","10001","01010","00100","00100","00100","00100"],
    "Z":["11111","00001","00010","00100","01000","10000","11111"],
    "0":["01110","10001","10011","10101","11001","10001","01110"],
    "1":["00100","01100","00100","00100","00100","00100","01110"],
    "2":["01110","10001","00001","00010","00100","01000","11111"],
    "3":["11110","00001","00001","01110","00001","00001","11110"],
    "4":["00010","00110","01010","10010","11111","00010","00010"],
    "5":["11111","10000","10000","11110","00001","00001","11110"],
    "6":["01110","10000","10000","11110","10001","10001","01110"],
    "7":["11111","00001","00010","00100","01000","01000","01000"],
    "8":["01110","10001","10001","01110","10001","10001","01110"],
    "9":["01110","10001","10001","01111","00001","00001","01110"],
    ".":["00000","00000","00000","00000","00000","01100","01100"],
    "/":["00001","00010","00100","01000","10000","00000","00000"],
    " ":[ "00000","00000","00000","00000","00000","00000","00000" ],
    "-":[ "00000","00000","00000","11111","00000","00000","00000" ]
  };

  function drawGlyph(x, y, glyph, color, s) {
    g.fillStyle = color;
    for (let row=0; row<7; row++) {
      const line = glyph[row];
      for (let col=0; col<5; col++) if (line[col] === "1") g.fillRect(x + col*s, y + row*s, s, s);
    }
  }
  function drawText5x7(x, y, text, color="#cfcfcf", scale=1, outline=null) {
    const s = scale|0;
    const chars = text.toUpperCase().split("");
    let cx = x|0;
    for (const ch of chars) {
      const glyph = FONT[ch] || FONT[" "];
      if (outline) {
        drawGlyph(cx-1*s, y, glyph, outline, s);
        drawGlyph(cx+1*s, y, glyph, outline, s);
        drawGlyph(cx, y-1*s, glyph, outline, s);
        drawGlyph(cx, y+1*s, glyph, outline, s);
      }
      drawGlyph(cx, y, glyph, color, s);
      cx += 6*s;
    }
  }

  // ============================================================
  // Hearts (pixel, like reference)
  // ============================================================
  const HEART_MASK = [
    "00111100",
    "01111110",
    "11111111",
    "11111111",
    "01111110",
    "00111100",
    "00011000",
    "00000000",
  ];
  const HEART_HI = [
    "00110000",
    "01000000",
    "10000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
  ];

  function blitMask(px, py, mask, size, color) {
    g.fillStyle = color;
    for (let y=0; y<mask.length; y++) for (let x=0; x<mask[0].length; x++)
      if (mask[y][x] === "1") g.fillRect(px + x*size, py + y*size, size, size);
  }
  function blitOutline(px, py, mask, size, color) {
    g.fillStyle = color;
    const h = mask.length, w = mask[0].length;
    const isOne = (x,y)=> (y>=0&&y<h&&x>=0&&x<w&&mask[y][x]==="1");
    for (let y=0; y<h; y++) for (let x=0; x<w; x++) {
      if (mask[y][x] !== "1") continue;
      const edge = !isOne(x+1,y) || !isOne(x-1,y) || !isOne(x,y+1) || !isOne(x,y-1);
      if (edge) g.fillRect(px + x*size, py + y*size, size, size);
    }
  }

  function drawHeart(px, py, size=1, variant=0) {
    const palette = [
      { fill:"#ff6b7a", hi:"#ffb4be", edge:"#b63c45", glow:"rgba(255,107,122,0.18)" },
      { fill:"#ff7ea3", hi:"#ffd0dc", edge:"#b63c70", glow:"rgba(255,126,163,0.16)" },
      { fill:"#ff4f5f", hi:"#ffb0b8", edge:"#a62a35", glow:"rgba(255,79,95,0.16)" },
    ][variant % 3];

    // subtle glow
    for (let oy=-1; oy<=1; oy++) for (let ox=-1; ox<=1; ox++) {
      if (!ox && !oy) continue;
      blitMask(px + ox*size, py + oy*size, HEART_MASK, size, palette.glow);
    }
    blitOutline(px, py, HEART_MASK, size, palette.edge);
    blitMask(px, py, HEART_MASK, size, palette.fill);
    blitMask(px, py, HEART_HI,   size, palette.hi);
  }

  function drawHeartDim(px, py) {
    blitOutline(px, py, HEART_MASK, 1, "#2a1418");
    blitMask(px, py, HEART_MASK, 1, "#3a2026");
  }

  // ============================================================
  // Cupid Bow + Arrow (same as before, stays low)
  // ============================================================
  function clampAngle(a, min, max) {
    while (a <= -Math.PI) a += Math.PI*2;
    while (a > Math.PI) a -= Math.PI*2;
    if (a > 0) a -= Math.PI*2;
    return Math.max(min, Math.min(max, a));
  }

  function drawHeartTip(x, y, ang, fill, edge) {
    const mask = [
      "011011",
      "111111",
      "111111",
      "011110",
      "001100",
      "000000",
    ];
    g.save();
    g.translate(x, y);
    g.rotate(ang);
    g.translate(2, 0);
    blitOutline(-3, -3, mask, 1, edge);
    blitMask(-3, -3, mask, 1, fill);
    g.restore();
  }

  function drawFeathers(x, y, ang, fill, edge) {
    g.save();
    g.translate(x, y);
    g.rotate(ang);
    const mask = [
      "00110000",
      "01111000",
      "11111100",
      "01111110",
      "00111100",
      "00011000",
    ];
    blitOutline(-6, -3, mask, 1, edge);
    blitMask(-6, -3, mask, 1, fill);
    g.restore();
  }

  function drawCupidBowAndArrow(cx, cy, aimAngle) {
    aimAngle = clampAngle(aimAngle, -Math.PI + 0.15, -0.15);

    const gold1 = "#d2a56c", gold2 = "#9a6a3f", goldHi = "#f0d3a3";
    const string = "#d9d9d9";
    const R = 22;
    const a1 = aimAngle - 1.05, a2 = aimAngle + 1.05;

    const ex1 = cx + Math.cos(a1)*R, ey1 = cy + Math.sin(a1)*R;
    const ex2 = cx + Math.cos(a2)*R, ey2 = cy + Math.sin(a2)*R;

    g.lineCap = "round";
    g.strokeStyle = gold2; g.lineWidth = 4; g.beginPath(); g.arc(cx, cy, R, a1, a2); g.stroke();
    g.strokeStyle = gold1; g.lineWidth = 2; g.beginPath(); g.arc(cx, cy, R, a1, a2); g.stroke();
    g.strokeStyle = goldHi; g.lineWidth = 1; g.beginPath(); g.arc(cx, cy, R-2, a1+0.05, a2-0.05); g.stroke();

    function curl(x,y,dir) {
      g.strokeStyle = gold2; g.lineWidth = 2;
      g.beginPath();
      g.arc(x + dir*4, y, 6, dir>0 ? Math.PI*0.2 : Math.PI*0.8, dir>0 ? Math.PI*1.25 : Math.PI*1.75);
      g.stroke();
      g.strokeStyle = gold1; g.lineWidth = 1;
      g.beginPath();
      g.arc(x + dir*4, y, 5, dir>0 ? Math.PI*0.2 : Math.PI*0.8, dir>0 ? Math.PI*1.25 : Math.PI*1.75);
      g.stroke();
    }
    curl(ex1, ey1, -1); curl(ex2, ey2, +1);

    const pull = 10;
    const ax = cx + Math.cos(aimAngle)*pull;
    const ay = cy + Math.sin(aimAngle)*pull;

    g.strokeStyle = string; g.lineWidth = 1;
    g.beginPath(); g.moveTo(ex1, ey1); g.lineTo(ax, ay); g.lineTo(ex2, ey2); g.stroke();

    const shaftLen = 24;
    const sx = cx + Math.cos(aimAngle)*2;
    const sy = cy + Math.sin(aimAngle)*2;
    const tx = sx + Math.cos(aimAngle)*shaftLen;
    const ty = sy + Math.sin(aimAngle)*shaftLen;

    g.strokeStyle = "#e6e6e6"; g.lineWidth = 1;
    g.beginPath(); g.moveTo(sx, sy); g.lineTo(tx, ty); g.stroke();

    drawFeathers(sx - Math.cos(aimAngle)*2, sy - Math.sin(aimAngle)*2, aimAngle, "#ff7ea3", "#b63c70");
    drawHeartTip(tx, ty, aimAngle, "#ff6b7a", "#b63c45");
  }

  function drawArrowInFlight(x, y, angle) {
    const dx = Math.cos(angle), dy = Math.sin(angle);
    const len = 22;
    const x2 = x + dx*len, y2 = y + dy*len;

    g.strokeStyle = "#e6e6e6"; g.lineWidth = 1;
    g.beginPath(); g.moveTo(x, y); g.lineTo(x2, y2); g.stroke();

    drawFeathers(x - dx*2, y - dy*2, angle, "#ff7ea3", "#b63c70");
    drawHeartTip(x2, y2, angle, "#ff6b7a", "#b63c45");
  }

  // ============================================================
  // HEART ORBIT PATH (not a circle)
  // ============================================================
// This is the "shape they follow". Hearts move along this curve.
// Heart-shaped path (pointy top), clockwise motion is handled by ring.ang update.
// ============================================================
function orbitPos(theta) {
  const cx = W/2;
  const cy = H/2 - 10;

  // Heart curve base (parametric):
  // x = 16 sin^3(t)
  // y = 13 cos(t) - 5 cos(2t) - 2 cos(3t) - cos(4t)
  // We invert y to make the "point" go UP on canvas.
  const t = theta;

  let x = 16 * Math.pow(Math.sin(t), 3);
  let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);

  // Canvas y+ is down; invert for point-up heart
  y = -y;

  // Scale to fit your screen composition
  const sx = 6.2;  // width
  const sy = 5.6;  // height
  x *= sx;
  y *= sy;

  // Slight tilt to match the vibe
  const tilt = -0.10;
  const ct = Math.cos(tilt), st = Math.sin(tilt);
  const xr = x*ct - y*st;
  const yr = x*st + y*ct;

  return { x: cx + xr, y: cy + yr };
}

// ============================================================
// Game state
// ============================================================
const State = { INTRO: 0, GAME: 1, WIN: 2 };
let state = State.INTRO;

const ring = {
  ang: 0,
  speed: 0.55, // clockwise => ring.ang decreases in the loop
  hearts: []
};

function resetHearts() {
  const count = 12;
  ring.hearts = [];
  for (let i=0; i<count; i++) {
    ring.hearts.push({
      phase: (i / count) * Math.PI * 2,
      hit: false,
      variant: i % 3
    });
  }
}

const bow = { x: W/2, y: H - 18 };
let aimAngle = -Math.PI/2;
let arrows = [];
let canShoot = true;
let shootCooldown = 0;

function resetGame() {
  resetHearts();
  arrows = [];
  aimAngle = -Math.PI/2;
  canShoot = true;
  shootCooldown = 0;
  state = State.GAME;
}

// ============================================================
// Input (keyboard + pointer) - mobile tap works as A and click
// ============================================================

  const keys = new Set();
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    keys.add(k);

    if (k === "a") {
      if (state === State.INTRO) resetGame();
    }
    if (k === "r") {
      if (state !== State.INTRO) resetGame();
    }
    if (k === " " || k === "enter") {
      if (state === State.GAME) shoot();
      if (state === State.WIN) resetGame();
    }
  });
  window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

  let pointerDown = false;

  canvas.addEventListener("pointerdown", (e) => {
    canvas.setPointerCapture(e.pointerId);
    pointerDown = true;

    if (state === State.INTRO) { // tap/click = "A"
      resetGame();
      return;
    }

    const p = toInternal(e.clientX, e.clientY);
    aimFromPoint(p.x, p.y);

    if (state === State.GAME) shoot();
    else if (state === State.WIN) resetGame();
  });

  canvas.addEventListener("pointermove", (e) => {
    if (!pointerDown && e.pointerType !== "mouse") return;
    const p = toInternal(e.clientX, e.clientY);
    aimFromPoint(p.x, p.y);
  });

  canvas.addEventListener("pointerup", () => pointerDown = false);
  canvas.addEventListener("pointercancel", () => pointerDown = false);

  function aimFromPoint(mx, my) {
    if (state === State.INTRO) return;
    aimAngle = Math.atan2(my - bow.y, mx - bow.x);
    aimAngle = clampAngle(aimAngle, -Math.PI + 0.15, -0.15);
  }

  function shoot() {
    if (!canShoot) return;
    canShoot = false;
    shootCooldown = 0.18;

    const sx = bow.x + Math.cos(aimAngle)*12;
    const sy = bow.y + Math.sin(aimAngle)*12;

    arrows.push({
      x: sx, y: sy,
      vx: Math.cos(aimAngle) * 175,
      vy: Math.sin(aimAngle) * 175,
      angle: aimAngle,
      alive: true
    });
  }

  // ============================================================
  // Collision (segment vs circle approx)
  // ============================================================
  function segmentCircleHit(x1,y1,x2,y2,cx,cy,r) {
    const dx = x2-x1, dy = y2-y1;
    const l2 = dx*dx + dy*dy;
    if (l2 === 0) return false;
    let t = ((cx-x1)*dx + (cy-y1)*dy) / l2;
    t = Math.max(0, Math.min(1, t));
    const px = x1 + t*dx;
    const py = y1 + t*dy;
    const dpx = px-cx, dpy = py-cy;
    return (dpx*dpx + dpy*dpy) <= r*r;
  }

  // ============================================================
  // Render
  // ============================================================
  function clear() {
    g.fillStyle = "#000";
    g.fillRect(0,0,W,H);
  }

  function blink(t, hz) { return (Math.floor(t * hz) % 2) === 0; }

  // Hearts move ALONG the custom path
  function drawHeartsOrbit() {
    for (const hrt of ring.hearts) {
      // Each heart has its own phase offset around the path.
      // ring.ang moves all hearts clockwise along the same curve.
      const theta = hrt.phase + ring.ang;

      const p = orbitPos(theta);
      const px = (p.x - 4)|0;
      const py = (p.y - 4)|0;

      if (!hrt.hit) drawHeart(px, py, 1, hrt.variant);
      else drawHeartDim(px, py);
    }
  }

  function drawIntro(t) {
    clear();
    drawHeartsOrbit();

    const title = "LULU";
    const sc = 3;
    const tw = title.length * 6 * sc;
    drawText5x7((W/2 - tw/2)|0, (H/2 - 12)|0, title, "#ff6b7a", sc, "#7c1f2a");

    drawText5x7(W - 6*6 - 2, 10, "v092025", "#9a9a9a", 1);

    drawText5x7(10, H - 72, "CUSTOM MADE FOR", "#9a9a9a", 1);
    drawText5x7(10, H - 60, "MY BELOVED LOURDES", "#d9d9d9", 1);
    drawText5x7(10, H - 48, "PUSH A TO ADVANCE", blink(t, 2.1) ? "#d9d9d9" : "#000000", 1);
    drawText5x7(10, H - 18, "COPYRIGHT 2025 BY NICO", "#9a9a9a", 1);
  }

  function drawGame() {
    clear();
    drawHeartsOrbit();
    drawCupidBowAndArrow(bow.x, bow.y, aimAngle);

    for (const a of arrows) {
      if (!a.alive) continue;
      drawArrowInFlight(a.x, a.y, a.angle);
    }
  }

  function drawWin(t) {
    drawGame();
    const msg = "LULU Y NICO";
    const sc = 2;
    const mw = msg.length * 6 * sc;
    const on = blink(t, 0.9);
    drawText5x7((W/2 - mw/2)|0, (H/2 - 6)|0, msg, on ? "#ff6b7a" : "#000000", sc, "#7c1f2a");
  }

  // ============================================================
  // Loop
  // ============================================================
  resetHearts();
  let last = performance.now();

  function loop(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;
    const t = now / 1000;

    // CLOCKWISE movement along the curve:
    ring.ang -= ring.speed * dt;

    if (state !== State.INTRO) {
      if (keys.has("arrowleft")) aimAngle -= 1.6 * dt;
      if (keys.has("arrowright")) aimAngle += 1.6 * dt;
      aimAngle = clampAngle(aimAngle, -Math.PI + 0.15, -0.15);

      if (!canShoot) {
        shootCooldown -= dt;
        if (shootCooldown <= 0) canShoot = true;
      }

      for (const a of arrows) {
        if (!a.alive) continue;
        const px = a.x, py = a.y;

        a.x += a.vx * dt;
        a.y += a.vy * dt;
        a.angle = Math.atan2(a.vy, a.vx);

        if (a.x < -40 || a.x > W+40 || a.y < -40 || a.y > H+40) {
          a.alive = false;
          continue;
        }

        // collision with hearts (approx circle)
        for (const hrt of ring.hearts) {
          if (hrt.hit) continue;
          const theta = hrt.phase + ring.ang;
          const p = orbitPos(theta);

          if (segmentCircleHit(px, py, a.x, a.y, p.x, p.y, 6)) {
            hrt.hit = true;
            break; // arrow continues through
          }
        }
      }

      if (state === State.GAME && ring.hearts.every(h => h.hit)) {
        state = State.WIN;
      }
    }

    if (state === State.INTRO) drawIntro(t);
    else if (state === State.GAME) drawGame();
    else drawWin(t);

    present();
    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
